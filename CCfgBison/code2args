%%
Marker_If : epsilon {
				$$ = global_code.size();
#ifdef debug
cout << "Marker if :" << $$ << endl;
#endif

			}
		;
Marker_Else : epsilon {
				$$ = new attr();
				$$->nextlist = ((compiler *)c)->makelist(global_code.size());
				code_element temp;
				temp.data1 = Jump;

				global_code.push_back(temp);
			}
		;
Marker_For : epsilon  {
				$$ = global_code.size();
				code_element temp;
				temp.data1 = Jump;

				global_code.push_back(temp);
}

epsilon : {;}   /*The epsilon rule*/

code1 : code 
			{
				((compiler *)c)->backpatch($1->nextlist,global_code.size());
			}

code  : decl Marker_If code	{$$ = new attr();
						$$->nextlist = $3->nextlist;
						((compiler *)c)->backpatch($1->nextlist,$2);
						free($1);
						free($3);
						}
	| decl {
				$$ = (attr*)malloc(sizeof(attr));
				$$->nextlist = $1->nextlist;
			 	free($1);
			}
	;
decl  : type identifier';' {
							$$ = new attr();
							if(current_symbol_table->table.find(string( $2->var_name[0])) != current_symbol_table->table.end())
								yyerror("error: redeclaration \n");
							else
							{
								$2->my_type = $1->my_type;
								$2->dimension[0]= $1->dimension[0];
							} 
							

							free($1);
							free($2);
							}
	| T_TYPEDEF type ID';'  {$$ = new attr();

								free($2);}
	| type func 

	{
		struct llm temp;

		temp.my_type= $1->my_type; 
		temp.dimension = $1->dimension[0];
		int total = temp.paramlist.total = $2->my_params.total;

		for (int i=0;i<total;i++)
		{
			temp.paramlist.dimension[i] = $2->my_params.dimension[i];
			temp.paramlist.my_type[i] = $2->my_params.my_type[i];
			temp.paramlist.my_args[i] = $2->my_params.my_args[i];

		}

		current_symbol_table->table[$2->lexeme]=(temp);
	}

	 block   {
								$$ = new attr();
								if ($1->my_type == $4->my_type)
								{
									if ($1->dimension[0] == $4->dimension[0])
									{	/* Everything is fine. Enter in symbol table */
									}
									else
									{
										yyerror("Dimension Mismatch\n");
									}
								}
								else yyerror("Type mismatch: Return type doesn't match declared type\n");

								$$->nextlist = $4->nextlist;

								//printf("type is %d. block is %d\n",$1->my_type,$3->my_type);
								free($1);
								free($2);
								free($4);
								}	/*This is for function definition only. No rule yet for function declation.*/
	| void func
	{
		struct llm temp;

		temp.my_type= $1->my_type; 
		temp.dimension = $1->dimension[0];
		int total = temp.paramlist.total = $2->my_params.total;

		for (int i=0;i<total;i++)
		{
			temp.paramlist.dimension[i] = $2->my_params.dimension[i];
			temp.paramlist.my_type[i] = $2->my_params.my_type[i];
			temp.paramlist.my_args[i] = $2->my_params.my_args[i];

		}

		current_symbol_table->table[$2->lexeme]=(temp);
	}

	 block {
								$$ = new attr();
								if ($1->my_type == $4->my_type)
								{
									if ($1->dimension[0] == $4->dimension[0])
									{	/* Everything is fine. Enter in symbol table */
									}
									else
									{
										yyerror("Dimension Mismatch\n");
									}
								}
								else yyerror("Type mismatch: Return type doesn't match declared type\n");

								$$->nextlist = $4->nextlist;


								free($1);
								free($2);
								free($4);
								}	/*void type, since allowed only for functions must be separated. Don't allow return stmts for such blocks. Must define another type of block to do this.*/
	| T_STRUCT ID block';'  {$$ = (attr*)malloc(sizeof(attr));
								free($3);
								}
	| T_HEADER					{$$ = (attr*)	malloc(sizeof(attr));}
	;
/*	| #define macro const*/
type  : type '*' %prec DEREF   {
								$$ = (attr*)malloc(sizeof(attr));
								$$->my_type = $1->my_type;
								$$->dimension[0] = $1->dimension[0]+1;
								free($1);
								}
	| basic  {
				$$ = (attr*)malloc(sizeof(attr)); 
				$$->my_type=$1->my_type; 
				$$->dimension[0] = $1->dimension[0];
				free($1);
				}
	;
basic : T_LONG_LONG  			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Long_long; $$->dimension[0] = 0; }
	| T_INT 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Int; $$->dimension[0] = 0; }
	| T_CHAR 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Char; $$->dimension[0] = 0; }
	| T_FLOAT 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Float; $$->dimension[0] = 0; }
	| T_DOUBLE 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Double; $$->dimension[0] = 0; }
	| T_BOOL			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Bool; $$->dimension[0] = 0; }
	;
void  : void '*' %prec DEREF   {
				$$ = (attr*)malloc(sizeof(attr));
				$$->my_type = $1->my_type;
				$$->dimension[0] = $1->dimension[0]+1;
				free($1);
				}
	| T_VOID  {
				$$ = (attr*)malloc(sizeof(attr));
				$$->my_type = Void;
				$$->dimension[0] = 0;
				}
	;
func  : ID'('args')'   {
						$$ = new lexemeNparam();
						$$->lexeme = string($1);
						int total = $$->my_params.total = $3->total;

						for (int i=0;i<total;i++)
						{
							$$->my_params.dimension[i] = $3->dimension[i];
							$$->my_params.my_type[i] = $3->my_type[i];
							$$->my_params.my_args[i] = $3->my_args[i];

						}

						free($3);
						}
	| ID'('')'   {
							$$ = new lexemeNparam();
							$$->lexeme = string($1);
							$$->my_params.total = 0;

							}

	| T_MAIN'('args')'   {
							$$ = new lexemeNparam();
							$$->lexeme = "main";
							if (!maindef)
								maindef = 1;
							else yyerror("Conflicting declaration of function main");
							 free($3);
							}
	| T_MAIN'('')'  {
							$$ = new lexemeNparam();
							$$->lexeme = "main";
							if (!maindef)
								maindef = 1;
							else yyerror("Conflicting declaration of function main");

							}
	;
args  : args ',' type identifier    {
									$$ = new funcparams();

									for (int i=0;i < $1->total;i++)
									{
										$$->my_args[i] = $1->my_args[i];
										$$ -> my_type[i]  =    $1-> my_type[i];
										$$->dimension[i] = $1->dimension[i];
									}
									int total = $$->total = $1->total+1;
									total--;
									$$->my_args[total] = $4->place;
									$$->my_type[total] = $3->my_type;
									$$->dimension[total] = $3->dimension[0] + $4->dimension[0];
									free($1); 
									free($3);
									delete $4;
								}
	| type identifier  {
							$$ = new funcparams();
							int total = 0;
							$$->my_args[total] = $2->place;
							$$->my_type[total] = $1->my_type;
							$$->dimension[total] = $1->dimension[0] + $2->dimension[0];
							$$->total = 1;
							free($1); 
							free($2);
							}
	;