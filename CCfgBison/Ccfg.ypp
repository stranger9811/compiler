%{
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include<string.h>
#include<vector>
#include <cstring>
#include<iostream>
#include <utility>
#include <algorithm>
#include <map>
//#include "functions.h"

#define KNRM  "\x1B[0m"
#define KRED  "\x1B[31m"
#define KGRN  "\x1B[32m"
#define KYEL  "\x1B[33m"
#define KBLU  "\x1B[34m"
#define KMAG  "\x1B[35m"
#define KCYN  "\x1B[36m"
#define KWHT  "\x1B[37m"


using namespace std;
int no_line;
int totalerrs;
bool maindef;
struct symbol_table *current_symbol_table;
int max_index=0;
vector <struct code_element> global_code;
int A[1000][3];
extern void codegen();
extern void create_mips();

int yylex();
int yyparse();
int yywrap();

int newTemp() {
	max_index++;
	return max_index;		
}


int check_keyword(string identifier);
void yyerror(const char *s,string color=KRED,string e="")
{
	if(color==KRED)
   		totalerrs++;
    fprintf(stderr, "%sline %d: %s %s%s",color.c_str(),no_line, s,e.c_str(),KNRM);

}

void *c;
FILE *text;


%}

%code requires
{
	#include "resources.h"
}

%union {
long long integer;
long double real;
char lexeme[10000];
struct lexemeNparam *lexemeNparamlist;
struct funcparams *paramlist;
struct attr *attributes;
//Yet to include exponential numbers and hexadecimals.
};


%token T_STRUCT
%token T_BREAK
%token T_CONTINUE
%token T_TYPEDEF
%token T_CHAR
%token T_DOUBLE
%token T_INT
%token T_FLOAT
%token T_LONG_LONG
%token T_FOR
%token T_IF
%token T_ELSE
%token T_WHILE
%token T_GOTO
%token T_RETURN
%token T_PRINTF
%token T_VOID
%token T_SCANF
%token T_SIZEOF
%token T_UNSIGNED
%token T_SIGNED
%token T_CONST
%token T_SHORT
%token T_EXTERN
%token T_LONG
%token T_BOOL
%token T_APOS

%token <real> T_DEC_FLOAT
%token <integer> T_DEC_INT
%token <lexeme> T_STRING
%token <lexeme> T_HEADER
%token <lexeme> ID

%token <lexeme> T_MAIN
%token <lexeme> T_IO_INT
%token <lexeme> T_IO_LONG_LONG
%token <lexeme> T_IO_STRING
%token <lexeme> T_IO_FLOAT

%right '{'
%right '('
%right '['
%left ','
%right  T_MULT_SELF T_DIVIDE_SELF
%right  T_PLUS_SELF T_MINUS_SELF
%right  '='
%left T_OR
%left T_AND
%left '|'
%left '^'
%left '&'
%left T_EQUAL_TEST T_NOT_EQUAL
%left '>' T_GREATER_THAN_EQUAL
%left '<' T_LESS_THAN_EQUAL
%left '+' '-'
%left '*' '/' '%'
/*%right '&'                   address of a variable*/
%right DEREF 	/* using unary * for dereferncing a pointer.*/
/*%right   (type)              typecasting*/
%right  '!'
%right  UPLUS UMINUS	/*unary + and -*/
%right  T_ADD_ONE T_SUB_ONE
%left T_THIS_POINTER
%left '.'
%left ']'
%left ')'
%right '}'

%type<attributes> basic
%type<attributes> type
%type<attributes> identifier
%type<attributes> array
%type<attributes> init
%type<attributes> assign_stmt
%type<attributes> code
%type<attributes> decl
%type<attributes> void
%type<lexemeNparamlist> func
%type<paramlist> args
%type<attributes> brac_open
%type<attributes> brac_close
%type<attributes> block
%type<attributes> M
%type<integer> Marker_For
%type<integer> Marker_If
%type<attributes> Marker_Else
%type<attributes> S
%type<attributes> S1
%type<attributes> block_stmt
%type<attributes> expr
%type<attributes> number
%type<paramlist> exprlist


%start code1
%%
Marker_If : epsilon {
				$$ = global_code.size();
#ifdef debug
cout << "Marker if :" << $$ << endl;
#endif

			}
		;
Marker_Else : epsilon {
				$$ = new attr();
				$$->nextlist = ((compiler *)c)->makelist(global_code.size());
				code_element temp;
				temp.data1 = Jump;

				global_code.push_back(temp);
			}
		;
Marker_For : epsilon  {
				$$ = global_code.size();
				code_element temp;
				temp.data1 = Jump;

				global_code.push_back(temp);
}

epsilon : {;}   /*The epsilon rule*/

code1 : code 
			{
				((compiler *)c)->backpatch($1->nextlist,global_code.size());
			}

code  : decl Marker_If code	{$$ = new attr();
						$$->nextlist = $3->nextlist;
						((compiler *)c)->backpatch($1->nextlist,$2);
						free($1);
						free($3);
						}
	| decl {
				$$ = new attr();
				$$->nextlist = $1->nextlist;
			 	free($1);
			}
	;
decl  : type identifier';' {
							$$ = new attr();
							if(current_symbol_table->table.find(string( $2->var_name[0])) != current_symbol_table->table.end())
								yyerror("error: redeclaration \n");
							else
							{
								$2->my_type = $1->my_type;
								$2->dimension[0]= $1->dimension[0];
							} 
							

							free($1);
							free($2);
							}
	| T_TYPEDEF type ID';'  {$$ = new attr();

								free($2);}
	| type func 

	{
		struct llm temp;

		temp.my_type= $1->my_type; 
		temp.dimension = $1->dimension[0];
		temp.funcline = global_code.size();
		int total = temp.paramlist.total = $2->my_params.total;

		for (int i=0;i<total;i++)
		{
			temp.paramlist.dimension[i] = $2->my_params.dimension[i];
			temp.paramlist.my_type[i] = $2->my_params.my_type[i];
			temp.paramlist.my_args[i] = $2->my_params.my_args[i];

		}

		current_symbol_table->table[$2->lexeme]=(temp); 
		code_element setsp,setfp;
		setsp.data1 = setfp.data1 = Mipscode;

		setsp.data2 = "subu";
		setsp.arg1.var = "$sp";
		setsp.arg1.args_type = 1;
		setsp.arg2.var = "$sp";
		setsp.arg2.args_type = 1;
		setsp.result.int_val = STACKSIZE;
		setsp.result.args_type = 3;

		
	}

	 block   {
								$$ = new attr();
								if ($1->my_type == $4->my_type)
								{
									if ($1->dimension[0] == $4->dimension[0])
									{	/* Everything is fine. Enter in symbol table */
									}
									else
									{
										yyerror("Dimension Mismatch\n");
									}
								}
								else if($1->my_type == Void && !$4->isreturn) ;
								else yyerror("Type mismatch: Return type doesn't match declared type\n");

								$$->nextlist = $4->nextlist;

								free($1);
								free($2);
								free($4);
								}	/*This is for function definition only. No rule yet for function declation.*/
	| void func
	{
		struct llm temp;

		temp.my_type= $1->my_type; 
		temp.dimension = $1->dimension[0];
		temp.funcline = global_code.size();
		int total = temp.paramlist.total = $2->my_params.total;

		for (int i=0;i<total;i++)
		{
			temp.paramlist.dimension[i] = $2->my_params.dimension[i];
			temp.paramlist.my_type[i] = $2->my_params.my_type[i];
			temp.paramlist.my_args[i] = $2->my_params.my_args[i];

		}

		current_symbol_table->table[$2->lexeme]=(temp); 
		code_element setsp,setfp;
		setsp.data1 = setfp.data1 = Mipscode;

		setsp.data2 = "subu";
		setsp.arg1.var = "$sp";
		setsp.arg1.args_type = 1;
		setsp.arg2.var = "$sp";
		setsp.arg2.args_type = 1;
		setsp.result.int_val = STACKSIZE;
		setsp.result.args_type = 3;

		
	}

	 block {
								$$ = new attr();
								if ($1->my_type == $4->my_type && $4->isreturn)
								{
									if ($1->dimension[0] == $4->dimension[0])
									{	/* Everything is fine. Enter in symbol table */
									}
									else
									{
										yyerror("Dimension Mismatch\n");
									}
								}
								else if($1->my_type == Void && !$4->isreturn) ;
								else yyerror("Type mismatch: Return type doesn't match declared type\n");

								$$->nextlist = $4->nextlist;


								free($1);
								free($2);
								free($4);
								}	/*void type, since allowed only for functions must be separated. Don't allow return stmts for such blocks. Must define another type of block to do this.*/
	| T_STRUCT ID block';'  {$$ = new attr();
								free($3);
								}
	| T_HEADER					{
									$$ = new attr();
}
	;
/*	| #define macro const*/
type  : type '*' %prec DEREF   {
								$$ = new attr();
								$$->my_type = $1->my_type;
								$$->dimension[0] = $1->dimension[0]+1;
								free($1);
								}
	| basic  {
				$$ = new attr(); 
				$$->my_type=$1->my_type; 
				$$->dimension[0] = $1->dimension[0];
				free($1);
				}
	;
basic : T_LONG_LONG  			{$$ = new attr();$$->my_type=Long_long; $$->dimension[0] = 0; }
	| T_INT 			{$$ = new attr();$$->my_type=Int; $$->dimension[0] = 0; }
	| T_CHAR 			{$$ = new attr();$$->my_type=Char; $$->dimension[0] = 0; }
	| T_FLOAT 			{$$ = new attr();$$->my_type=Float; $$->dimension[0] = 0; }
	| T_DOUBLE 			{$$ = new attr();$$->my_type=Double; $$->dimension[0] = 0; }
	| T_BOOL			{$$ = new attr();$$->my_type=Bool; $$->dimension[0] = 0; }
	;
void  : void '*' %prec DEREF   {
				$$ = new attr();
				$$->my_type = $1->my_type;
				$$->dimension[0] = $1->dimension[0]+1;
				free($1);
				}
	| T_VOID  {
				$$ = new attr();
				$$->my_type = Void;
				$$->dimension[0] = 0;
				}
	;
func  : ID'('args')'   {
						$$ = new lexemeNparam();
						$$->lexeme = string($1);
						int total = $$->my_params.total = $3->total;

						for (int i=0;i<total;i++)
						{
							$$->my_params.dimension[i] = $3->dimension[i];
							$$->my_params.my_type[i] = $3->my_type[i];
							$$->my_params.my_args[i] = $3->my_args[i];

						}

						free($3);
						}
	| ID'('')'   {
							$$ = new lexemeNparam();
							$$->lexeme = string($1);
							$$->my_params.total = 0;

							}

	| T_MAIN'('args')'   {
							$$ = new lexemeNparam();
							$$->lexeme = "main";
							if (!maindef)
								maindef = 1;
							else yyerror("Conflicting declaration of function main");
							 free($3);
							}
	| T_MAIN'('')'  {
							$$ = new lexemeNparam();
							$$->lexeme = "main";
							if (!maindef)
								maindef = 1;
							else yyerror("Conflicting declaration of function main");

							}
	;
args  : args ',' type identifier    {
									$$ = new funcparams();

									for (int i=0;i < $1->total;i++)
									{
										$$->my_args[i] = $1->my_args[i];
										$$ -> my_type[i]  =    $1-> my_type[i];
										$$->dimension[i] = $1->dimension[i];
									}
									int total = $$->total = $1->total+1;
									total--;
									$$->my_args[total] = $4->place;
									$$->my_type[total] = $3->my_type;
									$$->dimension[total] = $3->dimension[0] + $4->dimension[0];
									free($1); 
									free($3);
									delete $4;
								}
	| type identifier  {
							$$ = new funcparams();
							int total = 0;
							$$->my_args[total] = $2->place;
							$$->my_type[total] = $1->my_type;
							$$->dimension[total] = $1->dimension[0] + $2->dimension[0];
							$$->total = 1;
							free($1); 
							free($2);
							}
	;
brac_open : '{' { 
					$$ = new attr();

					#ifdef debug
						printf("creating new symbol table\n");
					#endif
				  struct symbol_table *temp = new  symbol_table;
				  current_symbol_table->children.push_back(temp); 
				  temp->parent = current_symbol_table;

				  current_symbol_table = temp;
				 
		 }

brac_close : '}' {
				$$ = new attr();

				#ifdef debug
					printf("destroying symbol table\n");
				#endif
				  struct symbol_table *temp = current_symbol_table;
				  current_symbol_table = temp->parent;
				  delete temp;
		 }

block  : brac_open M brac_close  {	
									#ifdef debug
						 				cout << "block -> brac_open M brac_close \n";
						 			#endif
									$$ = new attr(); 
									$$->my_type = $2->my_type;
									$$->dimension[0] = $2->dimension[0];
									$$->isreturn = $2->isreturn;
									$$->nextlist = $2->nextlist;

									free($2);
									}
									/*block can either be many statements enclosed in braces or just one S.*/
	| S  						{$$ = new attr(); free($1);
}		/*S can again be multiple statments separated by comma.*/
	;

M  : M  Marker_If   S 
			{
				$$ = new attr();
				#ifdef debug
					cout << "M -> S M\n";
				#endif

				if ($1->isreturn)
					$$->my_type = $1->my_type;
				else if ($3->isreturn)
					$$->my_type = $3->my_type;
				else $$->my_type = Useless;
				$$->dimension[0] = $1->dimension[0];
				$$->isreturn = $1->isreturn || $3->isreturn;
				
				if ($$->my_type!=$3->my_type && $1->isreturn && $3->isreturn )
					yyerror("Different return types for same function\n");
#ifdef debug2
	printf("types are: %d %d\n",$$->my_type,$3->my_type);
#endif
				
				((compiler *)c)->backpatch($1->nextlist,$2);
				$$->nextlist = $3->nextlist;
				free($1);
				free($3);
			}	/*Expanding statements inside a block*/
	| S 	{
				#ifdef debug
						cout << "M -> S\n";
				#endif
				$$ = new attr();
				$$->my_type = $1->my_type;
				$$->dimension[0] = $1->dimension[0];	
				$$->isreturn = $1->isreturn;
				$$->nextlist = $1->nextlist;

				free($1);
				}
	;

S  : S1';'	{
				#ifdef debug
						cout << "S -> S1\n";
				#endif
				$$ = new attr();
				
				
				$$->my_type = $1->my_type;
				$$->isreturn = $1->isreturn;

				
				$$->dimension[0] = $1->dimension[0];

				$$->nextlist = $1->nextlist;

				free($1);
			}	/* comma terminated statement or a block statement like if, for, while */
	| block_stmt {
					#ifdef debug
							cout << "S -> block_stmt\n";
					#endif
					$$ = new attr();
					$$->my_type = $1->my_type;
					$$->isreturn = $1->isreturn;

					$$->nextlist = $1->nextlist;
					$$->dimension[0] = $1->dimension[0];
					free($1);
					}
	| ';' {
				$$ = new attr();
	}
	;

exprlist : exprlist ',' expr    {
				$$ = new funcparams();
				for (int i=0;i < $1->total;i++)
				{
					$$->my_args[i] = $1->my_args[i];
					$$ -> my_type[i]  =    $1-> my_type[i];
					$$->dimension[i] = $1->dimension[i];
				}
				int total = $$->total = $1->total+1;
				total--;
				$$->my_args[total] = $3->place;
				$$->my_type[total] = $3->my_type;
				$$->dimension[total] = $3->dimension[0];
				delete $1;
				delete $3;
	}

		| expr {
				$$ = new funcparams();
				int total = 0;
				$$->my_args[total] = $1->place;
				$$->my_type[total] = $1->my_type;
				$$->dimension[total] = $1->dimension[0];
				$$->total = 1;
				delete $1;
	}

		| epsilon   {
				$$ = new funcparams();
	}


S1  : expr ',' Marker_If  S1  {
					$$ = new attr(); 
					$$->my_type = $4->my_type; 
					$$->dimension[0] = $4->dimension[0];
					$$->isreturn = $4->isreturn;

					((compiler *)c)->backpatch($1->truelist,$3);
					((compiler *)c)->backpatch($1->falselist,$3);
					$$->truelist = $4->truelist;
					$$->falselist = $4->falselist;

					free($1);
					free($4);
				}	/*statements separated by comma or a declaration/initialization*/
	
	|expr  {
				$$ = new attr(); 
				$$->my_type = Bool;
				$$->dimension[0]= $1->dimension[0]; 
				$$->truelist = $1->truelist; 
				$$->falselist = $1->falselist; 
				free($1);
			}
	|type init {
			#ifdef debug
						 cout << "S1 -> type init\n";
			#endif
			$$ = new attr();
			struct llm temp;

			temp.my_type= $1->my_type; 
			for(int i=0;i<$2->index;i++) {
				/* checking if variable is already declared */

						if(current_symbol_table->table.find(string( $2->var_name[i])) != current_symbol_table->table.end())
							yyerror("error: redeclaration \n");
					
				/*   ------------------------------------ */
						else {
							temp.dimension = $2->dimension[i];
							int j = check_keyword(string($2->var_name[i])); // 1 if error
							if(j==1)
								yyerror("error: variable name cannot be a keyword \n");
							else if(j==0)
								current_symbol_table->table[string($2->var_name[i])]=(temp);
						}

			}
#ifdef debug
			printf("Variables declared \n"); 
				for(int i=0;i<$2->index;i++) {
					printf("%s %d\n",$2->var_name[i],$2->dimension[i]);
				}
			#endif
				$$->my_type = Useless;
				free($1);
				free($2);
	}
	| T_RETURN expr 	{
								$$ = new attr();
								$$->isreturn = 1;
								$$->my_type = $2->my_type;
								$$->dimension[0] = $2->dimension[0];
								free($2);
								}
	| T_RETURN 				{
								$$->isreturn = 1;
								$$ = new attr();
								$$->my_type = Void;
								$$->dimension[0] = 0;
						
								}
	;

init : assign_stmt',' init 	/*Denotes declaration/initialization. If initializing, use assign_stmt*/
						 {
						 		#ifdef debug
						 				cout << "init -> assign_stmt ',' init\n";
						 		#endif
						 		$$ = new attr();
								strcpy($$->var_name[0],$1->var_name[0]);
								$$->dimension[0] = $1->dimension[0];
								$$->index = 1;
								for(int i=0; i<$3->index; i++) {
									$$->dimension[$$->index] = $3->dimension[i];
									strcpy($$->var_name[$$->index],$3->var_name[i]);
									$$->index++;
								}
								free($1);
								free($3);
						} /* Initialization is not done properly. declaration check is done in the assignment statment. Such declarations will always fail since the variable is not yet entered in the symbol table. */
	| identifier ',' init {
								$$ = new attr();
								strcpy($$->var_name[0],$1->var_name[0]);
								$$->dimension[0] = $1->dimension[0];
								$$->index = 1;
								for(int i=0; i<$3->index; i++) {
									$$->dimension[$$->index] = $3->dimension[i];
									strcpy($$->var_name[$$->index],$3->var_name[i]);
									$$->index++;
								}
								free($1);
								free($3);
							} 
	| assign_stmt {
						#ifdef debug
						 				cout << "init -> assign_stmt\n";
						 		#endif
						$$ = new attr();
						strcpy($$->var_name[0],$1->var_name[0]);
						$$->dimension[0] = $1->dimension[0];
						$$->index = 1;
						free($1);
					}
	| identifier  {
					$$ = new attr();
					strcpy($$->var_name[0],$1->var_name[0]);
					$$->dimension[0] = $1->dimension[0];
					$$->index = 1;
					free($1);
				  }
	;

block_stmt : T_IF    '('   expr   ')'    brac_open     Marker_If    M    brac_close 	{
											#ifdef debug
												cout << "block_expr : T_IF '('expr')' '{'M'}'";
											#endif
											$$ = new attr();
											if ($3->my_type != Bool) yyerror("condition is not bool inside if statement");
											$$->my_type = $7->my_type;
											$$->dimension[0]= $7->dimension[0];

											((compiler *)c)->backpatch($3->truelist, $6);
											$$->nextlist = ((compiler *)c)->merge_list($3->falselist,$7->nextlist);
											
											delete $5;
											delete $8;
 											free($3); free($7);
}	/*without brace if statements not allowed!*/
	| T_IF     '('    expr    ')'     brac_open     Marker_If     M     brac_close  Marker_Else    T_ELSE     brac_open     Marker_If     M      brac_close
											{
												$$ = new attr();
												if ($3->my_type != Bool) yyerror("Condition is not bool inside if statement\n");										
												((compiler *)c)->backpatch($3->truelist, $6);
												((compiler *)c)->backpatch($3->falselist, $12);
												vector <int> temp;
												temp = ((compiler *)c)->merge_list($7->nextlist, $9->nextlist);
												$$->nextlist = ((compiler *)c)->merge_list(temp, $13->nextlist);
												
												delete $5;
												delete $8,delete $11,delete $14;
	 											free($3); free($7); free($13);
	 											free($9);
	 										}

	| T_FOR    '('   S1   ';'   Marker_If    S1    ';'    Marker_If    S1   Marker_For  ')'    brac_open   Marker_If    M    brac_close  
										{
											$$ = new attr();
											
											if($6->my_type != Bool) yyerror("Condition not bool in For statement\n");

											$$->my_type = $14->my_type;
											$$->dimension[0]= $14->dimension[0];										
											
											$$->nextlist = $6->falselist;
											((compiler *)c)->backpatch($14->nextlist, $8);
											global_code[$10].result.int_val = $5;
											((compiler *)c)->backpatch($6->truelist, $13);
											code_element temp;
											temp.data1 = Jump;
											temp.result.int_val = $8;
											global_code.push_back(temp);

											free($3);
											free($6);
											free($9);
											free($12);
											free($14);
											free($15);
										}

	| T_WHILE    Marker_If    '('   S1   ')'   brac_open    Marker_If     M     brac_close  {
									$$ = new attr();

									if($4->my_type != Bool) yyerror("Condition not bool in While statement\n");
									
									$$->my_type = $8->my_type;
									$$->dimension[0]= $8->dimension[0];

									((compiler *)c)->backpatch($8->nextlist, $2);
									((compiler *)c)->backpatch($4->truelist, $7);
									$$->nextlist = $4->falselist;
#ifdef debug
cout << "Marker if :" << $7 << endl;
#endif
									struct code_element temp;
									temp.data1 = Jump;
									temp.result.int_val = $2;

									global_code.push_back(temp);

									delete $6;
									delete $9; 
									free($4);
									free($8);
	}
	;

expr  : expr '+' expr 			{ 
						$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "+";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr+expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: PLUS does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: PLUS does not support bool and char\n");
						else {
							if($1->my_type==Double || $3->my_type==Double )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
	| ID '(' exprlist ')'	{
								$$ = new attr(); 
								char *s;
								symbol_table *temp = current_symbol_table;
								while (temp->parent != NULL)
									temp = temp->parent;
								if (temp->table.find(string( $1)) != temp->table.end())
								{
									funcparams paramlist = temp->table[(string($1 ))].paramlist;
									if (paramlist.total != $3->total)
									{
										sprintf(s,"%d arguments expected, %d given\n",paramlist.total,$3->total);
										yyerror(s);
									}
								 
									else for (int i=0;i<paramlist.total;i++)
									{
										if (paramlist.my_type[i] != $3->my_type[i])
										{
											sprintf(s,"Cannot convert %s to %s in argument %d of \
														function",((compiler *)c)->enumtostring($3->\
														my_type[i]).c_str(), ((compiler *)c)->enumtostring(\
														paramlist.my_type[i]).c_str(),i );

											yyerror(s);
										}
									}
								}								

								delete $3;
}
	| expr T_EQUAL_TEST expr	{
						
						$$ = new attr;
						$$->truelist = ((compiler *)c)->makelist(global_code.size());
						$$->falselist = ((compiler *)c)->makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = "==";
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr '<' expr			{
						$$ = new attr;
						$$->truelist = ((compiler *)c)->makelist(global_code.size());
						$$->falselist = ((compiler *)c)->makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = "<";
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr '>' expr			{
						$$ = new attr;
						$$->truelist = ((compiler *)c)->makelist(global_code.size());
						$$->falselist = ((compiler *)c)->makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = ">";
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr T_LESS_THAN_EQUAL expr	{
						$$ = new attr;
						$$->truelist = ((compiler *)c)->makelist(global_code.size());
						$$->falselist = ((compiler *)c)->makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = "<=";
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr T_GREATER_THAN_EQUAL expr{
						$$ = new attr;
						$$->truelist = ((compiler *)c)->makelist(global_code.size());
						$$->falselist = ((compiler *)c)->makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = ">=";
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr T_NOT_EQUAL expr		{
						$$ = new attr;
						$$->truelist = ((compiler *)c)->makelist(global_code.size());
						$$->falselist = ((compiler *)c)->makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = "!=";
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| assign_stmt  {
					$$ = new attr(); 
					$$->my_type = $1->my_type;
					$$->dimension[0] = $1->dimension[0];
					delete ($1);
}
    	| expr '-' expr 		{ 
    					$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "-";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr-expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: MINUS does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: MINUS does not support bool and char\n");
						else {
							if($1->my_type==Double || $3->my_type==Double )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
	
	| expr '*' expr 		{ 
						$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "*";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr*expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: MULTIPLY does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: MULTIPLY does not support bool and char\n");
						else {
							if($1->my_type==Double || $3->my_type==Double )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
    	| expr '/' expr 		{ 
    					$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr/expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: DIVIDE does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: DIVIDE does not support bool and char\n");
						else {
							if(($1->my_type==Double) || ($3->my_type==Double) )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
	| expr '%' expr   		{ 
						$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "%";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr\%expr\n");
						#endif

						if(!($1->my_type==Int || $1->my_type==Long_long || $1->my_type==Bool))        /* Added Bool*/
							yyerror("error: MOD supports only bool,int,long long");
						else if(!($3->my_type==Int || $3->my_type==Long_long || $3->my_type==Bool))
							yyerror("error: MOD supports only bool,int,long long");
						else
							$$->my_type=$3->my_type;
						free($1);
						free($3);
					}
	| expr T_AND Marker_If expr 		{
						$$ = new attr();
						((compiler *)c)->backpatch($1->truelist,$3);
						$$->truelist = $4->truelist;
						$$->falselist = ((compiler *)c)->merge_list($1->falselist,$4->falselist);


						if(!($1->my_type==Bool || $1->my_type==Int || $1->my_type==Long_long))
							yyerror("error: AND supports only bool,int,long long");
						else if(!($4->my_type==Bool || $4->my_type==Int || $4->my_type==Long_long))
							yyerror("error: AND supports only bool,int,long long");
						else 
							$$->my_type=Bool;
						free($1);
						free($4);
					}
	| expr T_OR Marker_If expr 		{	
						$$ = new attr();
 
						if(!($1->my_type==Bool || $1->my_type==Int || $1->my_type==Long_long))
							yyerror("error: OR supports only bool,int,long long. left operand is \n");
						else if(!($4->my_type==Bool || $4->my_type==Int || $4->my_type==Long_long))
							yyerror("error: OR supports only bool,int,long long. right operand is \n");
						else 
							$$->my_type=Bool;

						((compiler *)c)->backpatch($1->falselist,$3);
						$$->truelist = ((compiler *)c)->merge_list($1->truelist,$4->truelist);
						$$->falselist = $4->falselist;
						free($1);
						free($4);
					}
	| '!' expr    {$$ = new attr();
					$$->my_type = Bool;

					$$->truelist = $2->falselist;
					$$->falselist = $2->truelist;

					 free($2);
					 }
	| '('expr')'  {
						$$ = new attr();
						$$->my_type = $2->my_type; 
						free($2);
					}
	| identifier  {
			$$ = new attr();
			$$->place.var = $1->place.var; 

			struct code_element temp_code;
			temp_code.data2 = "=";
			temp_code.result.temp = newTemp();
			temp_code.result.args_type = 2;
			temp_code.arg1 =  $1->place;
			global_code.push_back(temp_code);
			$$->place  = temp_code.result; 

			struct symbol_table *temp = current_symbol_table;
			int flag = 1;
			while(flag) {
			           	if( temp->table.find(string( $1->var_name[0])) != temp->table.end()){
						$$->my_type = temp->table[string($1->var_name[0])].my_type;
#ifdef debug
printf("expr-->identifier:\nidentifier is of type %d\n",$$->my_type);
#endif
							flag = 0;
						$$->dimension[0] = temp->table[string($1->var_name[0])].dimension - $1->dimension[0];
				}
				if(temp->parent==NULL && flag==1) {
					yyerror("error: variable not declared\n");
					flag = 0;
				}
				temp = temp->parent;
			}
			free($1);
		  }
	| '+' expr %prec UPLUS {$$ = new attr();
$$->my_type=$2->my_type; free($2);}
	| '-' expr %prec UMINUS {$$ = new attr();
$$->my_type=$2->my_type; free($2);}
	|number {
				$$ = new attr();
				printf("args_type = %d\n",$1->place.args_type);
				$$->place = $1->place;

				struct code_element temp_code;
				temp_code.data2 = "=";
				temp_code.result.temp = newTemp();
				temp_code.result.args_type = 2;
				temp_code.arg1 =  $1->place;
				global_code.push_back(temp_code);

				$$->place  = temp_code.result; 

				$$->place.args_type = $$->place.args_type;
				$$->my_type = $1->my_type;
				$$->dimension[0] = 0;
			}
	| '*' expr %prec DEREF {
								$$ = new attr();
								$$->my_type=$2->my_type; 
								$$->dimension[0] = $2->dimension[0]+1;
								free($2);
								}
	| "true" 	{
				$$ = new attr();
				$$->truelist = ((compiler *)c)->makelist(global_code.size());

				struct code_element temp_code;
				temp_code.data1 = Jump;
				global_code.push_back(temp_code);
				$$->my_type = Bool;

			}

	| "false" {
				$$ = new attr();
				$$->falselist = ((compiler *)c)->makelist(global_code.size());

				struct code_element temp_code;
				temp_code.data1 = Jump;
				global_code.push_back(temp_code);
				$$->my_type = Bool;
	}
	;
	
assign_stmt : identifier '=' expr {
							#ifdef debug
								printf("In assign_stmt -> identifier '=' expr\n");

							#endif 
							$$ = new attr();
							$$->my_type = Void;
							struct code_element temp_code;
							temp_code.arg1 = $3->place;
							temp_code.result = $1->place;
							temp_code.data2 = "=";
							temp_code.data1 = Assignment;
							$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
							$$->code.push_back(temp_code);
							global_code.push_back(temp_code);


							#ifdef debug
								printf("===============CODE GENERATED====================\n");
								for(int i=0;i<global_code.size();i++) {
									if(global_code[i].data1==Jump) {
										cout << "jump instruction\n";
										continue;
									}
									cout << global_code[i].data2 << "\t";
									cout << "(" << global_code[i].arg1.var << "," << global_code[i].arg1.temp << "," << global_code[i].arg1.int_val << "," << global_code[i].arg1.float_val << "," << global_code[i].arg1.args_type << ")\t(" << global_code[i].arg2.var << ","<<global_code[i].arg2.temp << "," << global_code[i].arg2.int_val << "," << global_code[i].arg2.float_val << "," << global_code[i].arg2.args_type<<")\t(" << global_code[i].result.var << "," << global_code[i].result.temp << "," << global_code[i].result.int_val << "," << global_code[i].result.float_val << "," << global_code[i].result.args_type<< ")\n";

								}	
								printf("===============CODE GENERATION END====================\n");
							#endif 
	                       struct symbol_table *temp = current_symbol_table;
                       		int flag = 1;
                        	while(flag) {
                                        if( temp->table.find(string( $1->var_name[0])) != temp->table.end()){
                                                $$->my_type = temp->table[string($1->var_name[0])].my_type;
                                                flag = 0;
						$$->dimension[0] = temp->table[string($1->var_name[0])].dimension - $1->dimension[0];

                                	}
                                	if(temp->parent==NULL && flag==1) {
                                        	yyerror("error: variable not declared\n");
                                        	flag = 0;
                                	}
                                	temp = temp->parent;
                        	}
				enum type_enum t = $$->my_type;
				enum type_enum tt = $3->my_type; 
				if (t == Int && tt== Long_long)
					yyerror("Warning: assigning long long to an integer\n",KYEL);
				else if (t==Int && tt == Float)
					yyerror("Warning: assigning float to an int\n",KYEL);
				else if (t==Int && tt == Double)
					yyerror("Warning: assigning int to double\n",KYEL);
				else if (t==Float && tt == Double)
					yyerror("Warning: assigning float to a double\n",KYEL);
				else if (t==Long_long && tt == Float)
					yyerror("Warning: assigning long long to a float\n",KYEL);
				else if (t==Long_long && tt == Double)
					yyerror("Warning: assigning long long to a double\n",KYEL);
				else if (t != tt || $$->dimension[0] != $3->dimension[0] )
					yyerror("Warning: Type mismatch\n",KYEL);

				free($1);
				free($3);

				}/*Assignment statement.*/
	;
number : T_DEC_INT	{
						#ifdef debug 
							printf("number-> T_DEC_INT\n");
						#endif
						$$ = new attr();
						$$->place.int_val = $1;
						$$->place.args_type = 3;
						$$->my_type =Int;
					}
	| T_DEC_FLOAT {
						$$ = new attr();
						$$->place.float_val = $1;
						$$->place.args_type = 4;
						$$->my_type = Int;
					}
	;

identifier  : ID	{  	
						$$ = new attr();
						$$->place.var = $1;
						$$->place.args_type = 1;
						strcpy($$->var_name[0],$1);
							$$->dimension[0] = 0;
					 }/*Array can have infinite dimensions. Must do something about it in future.*/ 
		| ID array {
							$$ = new attr();
							strcpy($$->var_name[0],$1);
							$$->dimension[0] = $2->dimension[0];
							free($2);
		}
	;
array  : '[' ID ']' array  {$$ = new attr(); $$->dimension[0] = $4->dimension[0] +1; printf("%s",$2); free($4);}
	| '[' ID ']' {$$ = new attr(); $$->dimension[0] = 1;}
	| '[' T_DEC_INT ']' {$$ = new attr();  $$->dimension[0] = 1;}
	| '[' T_DEC_INT ']' array {$$ = new attr(); $$->dimension[0] = $4->dimension[0] + 1; free($4);}
	;
%%

int check_keyword(string identifier)
{
	if(!identifier.compare("auto"))
		return 1;
	else if(!identifier.compare("break"))
		return 1;
	else if(!identifier.compare("case"))
                return 1;
	else if(!identifier.compare("char"))
                return 1;
	else if(!identifier.compare("const"))
                return 1;
	else if(!identifier.compare("continue"))
                return 1;
	 else if(!identifier.compare("default"))
                return 1;
	 else if(!identifier.compare("do"))
                return 1;
	 else if(!identifier.compare("double"))
                return 1;
	 else if(!identifier.compare("else"))
                return 1;
	 else if(!identifier.compare("enum"))
                return 1;
	 else if(!identifier.compare("extern"))
                return 1;
	 else if(!identifier.compare("float"))
                return 1;
	 else if(!identifier.compare("for"))
                return 1;
	 else if(!identifier.compare("goto"))
                return 1;
	 else if(!identifier.compare("if"))
                return 1;
	 else if(!identifier.compare("int"))
                return 1;
	 else if(!identifier.compare("long"))
                return 1;
	 else if(!identifier.compare("register"))
                return 1;
	 else if(!identifier.compare("return"))
                return 1;
	 else if(!identifier.compare("short"))
                return 1;
	 else if(!identifier.compare("signed"))
                return 1;
	 else if(!identifier.compare("sizeof"))
                return 1;
	 else if(!identifier.compare("static"))
                return 1;
	 else if(!identifier.compare("struct"))
                return 1;
	 else if(!identifier.compare("switch"))
                return 1;
	 else if(!identifier.compare("typedef"))
                return 1;
	 else if(!identifier.compare("union"))
                return 1;
	 else if(!identifier.compare("unsigned"))
                return 1;
	 else if(!identifier.compare("void"))
                return 1;
	 else if(!identifier.compare("volatile"))
                return 1;
	 else if(!identifier.compare("while"))
                return 1;
	else
		return 0; 
}

void wrg(args a)
{
	switch (a.args_type)
	{
		case 1: cout << a.var;
				break;
		case 2: cout << "t" << a.temp;
				break;
		case 3: cout << a.int_val;
				break;
		case 4: cout << a.float_val;
				break;				
	}
}


void print()
{
	for (int i=0;i<global_code.size();i++)
	{
		code_element a=global_code[i];
		if (a.data1==Assignment)
		{
			cout << i << ":\t";
			 wrg(a.result); cout << "= ";
			 wrg(a.arg1);
			 cout << " " << a.data2 << " ";
			 wrg(a.arg2);
		}
		else if(a.data1==Jump)
		{
			cout << i << ":\t";
			if (a.data2 == "") cout << "\t\tgoto " << a.result.int_val;
			else
			{ 
				cout << "if ";
			 	wrg(a.arg1);
			 	cout << " " << a.data2 << " ";
			 	wrg(a.arg2);
			 	cout << " then goto " << a.result.int_val;
			}
		}
		cout << endl;
	}
}


int main()
{
		no_line = 1;
		maindef = 0;
		totalerrs = 0;
		current_symbol_table = new symbol_table;
		current_symbol_table->parent = NULL;
		c = (void *) (new compiler);
        yyparse();

        if (!maindef) yyerror("main function not defined");
		print();
		if (totalerrs>0)
		{
			printf("%d errors found: No code generated\n",totalerrs);
		    //return 0;
		}
		codegen();
		print();
		create_mips();
		return 0;
}
