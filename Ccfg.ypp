%{
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include<string.h>
#include<vector>
#include <cstring>
#include<iostream>
#include <utility>
#include <algorithm>
#include <map>

#define KNRM  "\x1B[0m"
#define KRED  "\x1B[31m"
#define KGRN  "\x1B[32m"
#define KYEL  "\x1B[33m"
#define KBLU  "\x1B[34m"
#define KMAG  "\x1B[35m"
#define KCYN  "\x1B[36m"
#define KWHT  "\x1B[37m"

using namespace std;
int no_line;
bool maindef;
struct symbol_table *current_symbol_table;
int max_index=0;
vector <struct code_element> global_code;

int yylex();
int yyparse();
int yywrap();

int newTemp() {
	max_index++;
	return max_index;		
}
void yyerror(const char *s,string color=KRED,string e="")
{

        
   fprintf(stderr, "%sline %d: %s %s%s",color.c_str(),no_line, s,e.c_str(),KNRM);

}
void backpatch(vector <int> lines, int label) {
	int i;
}
vector <int> makelist(int p) {
	vector <int> new1;
	new1.push_back(p);
	return new1;
}
vector <int> merge_list(vector <int> l1,vector <int> l2) {
	
	for(int i=0; i<l1.size(); i++) {
		l2.push_back(l1[i]);
	}
	return l2;
 }

%}

%code requires
{
	#include "resources.h"
}

%union {
long long integer;
long double real;
char lexeme[10000];
struct attr *attributes;
//Yet to include exponential numbers and hexadecimals.
};


%token T_STRUCT
%token T_BREAK
%token T_CONTINUE
%token T_TYPEDEF
%token T_CHAR
%token T_DOUBLE
%token T_INT
%token T_FLOAT
%token T_LONG_LONG
%token T_FOR
%token T_IF
%token T_ELSE
%token T_WHILE
%token T_GOTO
%token T_RETURN
%token T_PRINTF
%token T_VOID
%token T_SCANF
%token T_SIZEOF
%token T_UNSIGNED
%token T_SIGNED
%token T_CONST
%token T_SHORT
%token T_EXTERN
%token T_LONG
%token T_BOOL
%token T_APOS

%token <real> T_DEC_FLOAT
%token <integer> T_DEC_INT
%token <lexeme> T_STRING
%token <lexeme> T_HEADER
%token <lexeme> ID

%token <lexeme> T_MAIN
%token <lexeme> T_AND
%token <lexeme> T_GREATER_THAN_EQUAL
%token <lexeme> T_LESS_THAN_EQUAL
%token <lexeme> T_EQUAL_TEST
%token <lexeme> T_NOT_EQUAL
%token <lexeme> T_OR
%token <lexeme> T_PLUS_SELF
%token <lexeme> T_MINUS_SELF
%token <lexeme> T_MULT_SELF
%token <lexeme> T_DIVIDE_SELF
%token <lexeme> T_THIS_POINTER
%token <lexeme> T_ADD_ONE
%token <lexeme> T_SUB_ONE
%token <lexeme> T_IO_INT
%token <lexeme> T_IO_LONG_LONG
%token <lexeme> T_IO_STRING
%token <lexeme> T_IO_FLOAT

%right '{'
%right '('
%right '['
%left ','
%right  T_MULT_SELF T_DIVIDE_SELF
%right  T_PLUS_SELF T_MINUS_SELF
%right  '='
%left T_OR
%left T_AND
%left '|'
%left '^'
%left '&'
%left T_EQUAL_TEST T_NOT_EQUAL
%left '>' T_GREATER_THAN_EQUAL
%left '<' T_LESS_THAN_EQUAL
%left '+' '-'
%left '*' '/' '%'
/*%right '&'                   address of a variable*/
%right DEREF 	/* using unary * for dereferncing a pointer.*/
/*%right   (type)              typecasting*/
%right  '!'
%right  UPLUS UMINUS	/*unary + and -*/
%right  T_ADD_ONE T_SUB_ONE
%left T_THIS_POINTER
%left '.'
%left ']'
%left ')'
%right '}'

%type<attributes> basic
%type<attributes> type
%type<attributes> identifier
%type<attributes> array
%type<attributes> init
%type<attributes> assign_stmt
%type<attributes> code
%type<attributes> decl
%type<attributes> void
%type<attributes> func
%type<attributes> args
%type<attributes> brac_open
%type<attributes> brac_close
%type<attributes> block
%type<attributes> M
%type<integer> Marker_e
%type<attributes> S
%type<attributes> S1
%type<attributes> block_stmt
%type<attributes> stmt
%type<attributes> expr
%type<attributes> number


%start code
%%
Marker_e : epsilon {
				$$ = global_code.size()  + 1;
			}
		;

epsilon : {;}   /*The epsilon rule*/

code  : decl code	{$$ = (attr*)malloc(sizeof(attr));
						free($1);
						free($2);}
	| decl {$$ = (attr*)malloc(sizeof(attr));

			free($1);}
	;
decl  : type identifier';' {$$ = (attr*)malloc(sizeof(attr));
							if(current_symbol_table->table.find(string( $2->var_name[0])) != current_symbol_table->table.end())
								yyerror("error: redeclaration \n");
							else{
							$2->my_type = $1->my_type;
							$2->dimension[0]= $1->dimension[0];
							} 
							

							free($1);
							free($2);
							}
	| T_TYPEDEF type ID';'  {$$ = (attr*)malloc(sizeof(attr));

								free($2);}
	| type func block   {
								$$ = (attr*)malloc(sizeof(attr));
								if ($1->my_type == $3->my_type)
								{
									if ($1->dimension[0] == $3->dimension[0])
									{	/* Everything is fine. Enter in symbol table */
										struct llm temp;

										temp.my_type= $1->my_type; 
										temp.dimension = $1->dimension[0];
										current_symbol_table->table[string($2->var_name[0])]=(temp);									}
									else
									{
										yyerror("Dimension Mismatch\n");
									}
								}
								else yyerror("Type mismatch: Return type doesn't match declared type\n");
								printf("type is %d. block is %d\n",$1->my_type,$3->my_type);
								free($1);
								free($2);
								free($3);
								}	/*This is for function definition only. No rule yet for function declation.*/
	| void func block {
								$$ = (attr*)malloc(sizeof(attr));
								if ($1->my_type == $3->my_type)
								{
									if ($1->dimension[0] == $3->dimension[0])
									{	/* Everything is fine. Enter in symbol table */
										struct llm temp;

										temp.my_type= $1->my_type; 
										temp.dimension = $1->dimension[0];
										current_symbol_table->table[string($2->var_name[0])]=(temp);									}
									else
									{
										yyerror("Dimension Mismatch\n");
									}
								}
								else yyerror("Type mismatch: Return type doesn't match declared type\n");

								free($1);
								free($2);
								free($3);
								}	/*void type, since allowed only for functions must be separated. Don't allow return stmts for such blocks. Must define another type of block to do this.*/
	| T_STRUCT ID block';'  {$$ = (attr*)malloc(sizeof(attr));
								free($3);
								}
	| T_HEADER					{$$ = (attr*)	malloc(sizeof(attr));}
	;
/*	| #define macro const*/
type  : type '*' %prec DEREF   {
								$$ = (attr*)malloc(sizeof(attr));
								$$->my_type = $1->my_type;
								$$->dimension[0] = $1->dimension[0]+1;
								free($1);
								}
	| basic  {
				$$ = (attr*)malloc(sizeof(attr)); 
				$$->my_type=$1->my_type; 
				$$->dimension[0] = $1->dimension[0];
				free($1);
				}
	;
basic : T_LONG_LONG  			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Long_long; $$->dimension[0] = 0; }
	| T_INT 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Int; $$->dimension[0] = 0; }
	| T_CHAR 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Char; $$->dimension[0] = 0; }
	| T_FLOAT 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Float; $$->dimension[0] = 0; }
	| T_DOUBLE 			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Double; $$->dimension[0] = 0; }
	| T_BOOL			{$$ = (attr*)malloc(sizeof(attr));$$->my_type=Bool; $$->dimension[0] = 0; }
	;
void  : void '*' %prec DEREF   {
				$$ = (attr*)malloc(sizeof(attr));
				$$->my_type = $1->my_type;
				$$->dimension[0] = $1->dimension[0]+1;
				free($1);
				}
	| T_VOID  {
				$$ = (attr*)malloc(sizeof(attr));
				$$->my_type = Void;
				$$->dimension[0] = 0;
				}
	;
func  : ID'('args')'   {
						$$ = (attr*)malloc(sizeof(attr));
						strcpy($$->var_name[0],$1);
						 free($3);
						}
	| ID'('')'   {
							$$ = (attr*)malloc(sizeof(attr));
							strcpy($$->var_name[0],$1);

							}
	| T_MAIN'('args')'   {
							$$ = (attr*)malloc(sizeof(attr));
							if (!maindef)
								maindef = 1;
							else yyerror("Conflicting declaration of function main");
							 free($3);
							}
	| T_MAIN'('')'  {
							$$ = (attr*)malloc(sizeof(attr));
							if (!maindef)
								maindef = 1;
							else yyerror("Conflicting declaration of function main");

							}
	;
args  : type identifier',' args    {$$ = (attr*)malloc(sizeof(attr));   free($1); free($2);}
	| type identifier  {$$ = (attr*)malloc(sizeof(attr));   free($1); free($2);}
	;
brac_open : '{' { 
					$$ = new attr();

					#ifdef debug
						printf("creating new symbol table\n");
					#endif
				  struct symbol_table *temp = new  symbol_table;
				  current_symbol_table->children.push_back(temp); 
				  temp->parent = current_symbol_table;

				  current_symbol_table = temp;
				 
		 }

brac_close : '}' {
				$$ = new attr();

				#ifdef debug
					printf("destroying symbol table\n");
				#endif
				  struct symbol_table *temp = current_symbol_table;
				  current_symbol_table = temp->parent;
				  delete temp;
		 }

block  : brac_open M brac_close  {	
									#ifdef debug
						 				cout << "block -> brac_open M brac_close \n";
						 			#endif
									$$ = (attr*)malloc(sizeof(attr)); 
									$$->my_type = $2->my_type;
									$$->dimension[0] = $2->dimension[0];

									free($2);
									}
									/*block can either be many statements enclosed in braces or just one S.*/
	| S  						{$$ = (attr*)malloc(sizeof(attr)); free($1);
}		/*S can again be multiple statments separated by comma.*/
	;

M  : S M  	{
				$$ = (attr*)malloc(sizeof(attr));
				#ifdef debug
					cout << "M -> S M\n";
				#endif
				if ($1->my_type != Useless)
				{
					$$->my_type = $1->my_type;
					$$->dimension[0] = $1->dimension[0];
				}
				else
				{
					$$->my_type = $2->my_type;
					$$->dimension[0] = $2->dimension[0];
				}
				if ($$->my_type!=$2->my_type) yyerror("Different return types for same function\n");
				free($1);free($2);
				}	/*Expanding statements inside a block*/
	| S 	{
				#ifdef debug
						cout << "M -> S\n";
				#endif
				$$ = (attr*)malloc(sizeof(attr));
				$$->my_type = $1->my_type;
				$$->dimension[0] = $1->dimension[0];	
				free($1);
				}
	;

S  : S1';'	{
				#ifdef debug
						cout << "S -> S1\n";
				#endif
				$$ = (attr*)malloc(sizeof(attr));
				$$->my_type = $1->my_type;
				$$->dimension[0] = $1->dimension[0];
				free($1);
				}	/* comma terminated statement or a block statement like if, for, while */
	| block_stmt {
					#ifdef debug
							cout << "S -> block_stmt\n";
					#endif
					$$ = (attr*)malloc(sizeof(attr));
					$$->my_type = $1->my_type;
					$$->dimension[0] = $1->dimension[0];
					free($1);
					}
	;


S1  : stmt','S1  {$$ = (attr*)malloc(sizeof(attr)); $$->my_type = $3->my_type; free($1);
free($3);}	/*statements separated by comma or a declaration/initialization*/
	|stmt  {$$ = (attr*)malloc(sizeof(attr));$$->my_type = Useless; free($1);}
	|type init {
			#ifdef debug
						 cout << "S1 -> type init\n";
			#endif
			$$ = (attr*)malloc(sizeof(attr));
			struct llm temp;

			temp.my_type= $1->my_type; 
			for(int i=0;i<$2->index;i++) {
				/* checking if variable is already declared */

						if(current_symbol_table->table.find(string( $2->var_name[i])) != current_symbol_table->table.end())
							yyerror("error: redeclaration \n");
					
				/*   ------------------------------------ */
						else {
							temp.dimension = $2->dimension[i];
							current_symbol_table->table[string($2->var_name[i])]=(temp);
						}

			}
#ifdef debug
			printf("Variables declared \n"); 
				for(int i=0;i<$2->index;i++) {
					printf("%s %d\n",$2->var_name[i],$2->dimension[i]);
				}
			#endif
				$$->my_type = Useless;
				free($1);
				free($2);
	}
	| T_RETURN expr 	{
								$$ = (attr*)malloc(sizeof(attr));

								$$->my_type = $2->my_type;
								$$->dimension[0] = $2->dimension[0];
								free($2);
								}
	| T_RETURN 				{
								$$ = (attr*)malloc(sizeof(attr));
								$$->my_type = Void;
								$$->dimension[0] = 0;
						
								}
	;

init : assign_stmt',' init 	/*Denotes declaration/initialization. If initializing, use assign_stmt*/
						 {
						 		#ifdef debug
						 				cout << "init -> assign_stmt ',' init\n";
						 		#endif
						 		$$ = (attr*)malloc(sizeof(attr));
								strcpy($$->var_name[0],$1->var_name[0]);
								$$->dimension[0] = $1->dimension[0];
								$$->index = 1;
								for(int i=0; i<$3->index; i++) {
									$$->dimension[$$->index] = $3->dimension[i];
									strcpy($$->var_name[$$->index],$3->var_name[i]);
									$$->index++;
								}
								free($1);
								free($3);
						} /* Initialization is not done properly. declaration check is done in the assignment statment. Such declarations will always fail since the variable is not yet entered in the symbol table. */
	| identifier ',' init {
								$$ = (attr*)malloc(sizeof(attr));
								strcpy($$->var_name[0],$1->var_name[0]);
								$$->dimension[0] = $1->dimension[0];
								$$->index = 1;
								for(int i=0; i<$3->index; i++) {
									$$->dimension[$$->index] = $3->dimension[i];
									strcpy($$->var_name[$$->index],$3->var_name[i]);
									$$->index++;
								}
								free($1);
								free($3);
							} 
	| assign_stmt {
						#ifdef debug
						 				cout << "init -> assign_stmt\n";
						 		#endif
						$$ = (attr*)malloc(sizeof(attr));
						strcpy($$->var_name[0],$1->var_name[0]);
						$$->dimension[0] = $1->dimension[0];
						$$->index = 1;
						free($1);
					}
	| identifier  {
					$$ = (attr*)malloc(sizeof(attr));
					strcpy($$->var_name[0],$1->var_name[0]);
					$$->dimension[0] = $1->dimension[0];
					$$->index = 1;
					free($1);
				  }
	;

block_stmt : T_IF '('stmt')' '{' Marker_e M '}' 	{
											#ifdef debug
												cout << "block_stmt : T_IF '('stmt')' '{'M'}'";
											#endif
											$$ = (attr*)malloc(sizeof(attr));
											$$->my_type = $7->my_type;
											$$->dimension[0]= $7->dimension[0];
 											free($3); free($7);
}	/*without brace if statements not allowed!*/
	| T_IF '('stmt')' '{' Marker_e M '}' T_ELSE '{' Marker_e M '}' {$$ = (attr*)malloc(sizeof(attr));
											
	 											free($3); free($7); free($12);}

	| T_FOR '('S1';'S1';'S1')' '{' M '}'  {$$ = (attr*)malloc(sizeof(attr));
											
											$$->my_type = $10->my_type;
											$$->dimension[0]= $10->dimension[0];										
											free($3);
											free($5);
											free($7);
											free($10);
	}

	| T_WHILE '('S1')' '{' M '}'  {
									$$ = (attr*)malloc(sizeof(attr));	
									$$->my_type = $6->my_type;
									$$->dimension[0]= $6->dimension[0];
									free($3);
									free($6);
	}
	;
stmt: expr		{$$ = (attr*)malloc(sizeof(attr));free($1);}
	/*Useless non-terminal. Too lazy to update.*/
	;
expr  : expr '+' expr 			{ 
						$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "+";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr+expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: PLUS does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: PLUS does not support bool and char\n");
						else {
							if($1->my_type==Double || $3->my_type==Double )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
	| func			{$$ = (attr*)malloc(sizeof(attr)); free($1);
}
	| expr T_EQUAL_TEST expr	{
						$$ = (attr*)malloc(sizeof(attr));

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr '<' expr			{
						$$ = (attr*)malloc(sizeof(attr));

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr '>' expr			{
						$$ = (attr*)malloc(sizeof(attr));

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr T_LESS_THAN_EQUAL expr	{
						$$ = (attr*)malloc(sizeof(attr));

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr T_GREATER_THAN_EQUAL expr{
						$$ = new attr;
						$$->truelist = makelist(global_code.size());
						$$->falselist = makelist(global_code.size()+1);
						struct code_element temp;
						temp.data1 = Jump;
						temp.data2 = $2;
						temp.arg1 = $1->place;
						temp.arg2 = $3->place;

						global_code.push_back(temp);

						struct code_element temp2;
						temp2.data1 = Jump;

						global_code.push_back(temp2);

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| expr T_NOT_EQUAL expr		{
						$$ = (attr*)malloc(sizeof(attr));

						$$->my_type=Bool;
						free($1);
						free($3);
					}
	| assign_stmt  {$$ = (attr*)malloc(sizeof(attr)); free($1);
}
    	| expr '-' expr 		{ 
    					$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "-";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr-expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: MINUS does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: MINUS does not support bool and char\n");
						else {
							if($1->my_type==Double || $3->my_type==Double )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
	
	| expr '*' expr 		{ 
						$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "*";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr*expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: MULTIPLY does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: MULTIPLY does not support bool and char\n");
						else {
							if($1->my_type==Double || $3->my_type==Double )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
    	| expr '/' expr 		{ 
    					$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr/expr\n");

						#endif

						if($1->my_type==Char || $1->my_type==Bool)
							yyerror("error: DIVIDE does not support bool and char\n");
						else if($3->my_type==Char || $3->my_type==Bool)
							yyerror("error: DIVIDE does not support bool and char\n");
						else {
							if(($1->my_type==Double) || ($3->my_type==Double) )
								$$->my_type=Double;
							else if($1->my_type==Float || $3->my_type==Float)
								$$->my_type=Float;
							else if($1->my_type==Long_long || $3->my_type==Long_long)
								$$->my_type=Long_long;
							else 
								$$->my_type=$1->my_type;
						}
						free($1);
						free($3);
					}
	| expr '%' expr   		{ 
						$$ = new attr();
						
						$$->place.temp = newTemp();
						$$->place.args_type = 2;
						struct code_element temp_code;
						temp_code.arg1 = $1->place;
						temp_code.arg2 = $3->place;
						temp_code.result = $$->place;
						temp_code.data2 = "%";
						temp_code.data1 = Assignment;

						$$->code.insert ($$->code.end(),$1->code.begin(),$1->code.end());
						$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
						$$->code.push_back(temp_code);
						global_code.push_back(temp_code);



						#ifdef debug
							printf("in expr-> expr\%expr\n");
						#endif

						if(!($1->my_type==Int || $1->my_type==Long_long || $1->my_type==Bool))        /* Added Bool*/
							yyerror("error: MOD supports only bool,int,long long");
						else if(!($3->my_type==Int || $3->my_type==Long_long || $3->my_type==Bool))
							yyerror("error: MOD supports only bool,int,long long");
						else
							$$->my_type=$3->my_type;
						free($1);
						free($3);
					}
	| expr T_AND Marker_e expr 		{
						$$ = new attr();
						//backpatch($1->falselist,$3);
						//$$->truelist = merge($1->truelist.begin(),$1->truelist.end(),$4->truelist.begin(),$4->truelist.end());
						for(int x=0; x<$4->falselist.size();x++) {
								$$->falselist.push_back($4->falselist[x]);
						}

						if(!($1->my_type==Bool || $1->my_type==Int || $1->my_type==Long_long))
							yyerror("error: AND supports only bool,int,long long");
						else if(!($4->my_type==Bool || $4->my_type==Int || $4->my_type==Long_long))
							yyerror("error: AND supports only bool,int,long long");
						else 
							$$->my_type=Bool;
						free($1);
						free($4);
					}
	| expr T_OR Marker_e expr 		{	
						$$ = (attr*)malloc(sizeof(attr));
 
						if(!($1->my_type==Bool || $1->my_type==Int || $1->my_type==Long_long))
							yyerror("error: OR supports only bool,int,long long. left operand is \n");
						else if(!($4->my_type==Bool || $4->my_type==Int || $4->my_type==Long_long))
							yyerror("error: OR supports only bool,int,long long. right operand is \n");
						else 
							$$->my_type=Bool;
						free($1);
						free($4);
					}
	| '!' expr    {$$ = (attr*)malloc(sizeof(attr));
$$->my_type = Bool; free($2);}
	| '('expr')'  {$$ = (attr*)malloc(sizeof(attr));
$$->my_type = $2->my_type; free($2);}
	| identifier  {
			$$ = new attr();
			$$->place.var = $1->place.var; 
			$$->place.args_type = 1;
			struct symbol_table *temp = current_symbol_table;
			int flag = 1;
			while(flag) {
			           	if( temp->table.find(string( $1->var_name[0])) != temp->table.end()){
						$$->my_type = temp->table[string($1->var_name[0])].my_type;
#ifdef debug
printf("expr-->identifier:\nidentifier is of type %d\n",$$->my_type);
#endif
							flag = 0;
						$$->dimension[0] = temp->table[string($1->var_name[0])].dimension - $1->dimension[0];
				}
				if(temp->parent==NULL && flag==1) {
					yyerror("error: variable not declared\n");
					flag = 0;
				}
				temp = temp->parent;
			}
			free($1);
		  }
	| '+' expr %prec UPLUS {$$ = (attr*)malloc(sizeof(attr));
$$->my_type=$2->my_type; free($2);}
	| '-' expr %prec UMINUS {$$ = (attr*)malloc(sizeof(attr));
$$->my_type=$2->my_type; free($2);}
	|number {
				$$ = new attr();
				$$->place = $1->place;
				$$->place.args_type = $$->place.args_type;
				$$->my_type = $1->my_type;
			}
	| '*' expr %prec DEREF {
								$$ = (attr*)malloc(sizeof(attr));
								$$->my_type=$2->my_type; 
								$$->dimension[0] = $2->dimension[0]+1;
								free($2);
								}
	;
	









assign_stmt : identifier '=' expr {
							#ifdef debug
								printf("In assign_stmt -> identifier '=' expr\n");

							#endif 
							$$ = new attr();
							$$->my_type = Void;
							struct code_element temp_code;
							temp_code.arg1 = $3->place;
							temp_code.result = $1->place;
							temp_code.data2 = "=";
							temp_code.data1 = Assignment;
							$$->code.insert ($$->code.end(),$3->code.begin(),$3->code.end());
							$$->code.push_back(temp_code);
							global_code.push_back(temp_code);


							#ifdef debug
								printf("===============CODE GENERATED====================\n");
								for(int i=0;i<global_code.size();i++) {
									if(global_code[i].data1==Jump) {
										cout << "jump instruction\n";
										continue;
									}
									cout << global_code[i].data2 << "\t";
									cout << "(" << global_code[i].arg1.var << "," << global_code[i].arg1.temp << "," << global_code[i].arg1.int_val << "," << global_code[i].arg1.float_val << "," << global_code[i].arg1.args_type << ")\t(" << global_code[i].arg2.var << ","<<global_code[i].arg2.temp << "," << global_code[i].arg2.int_val << "," << global_code[i].arg2.float_val << "," << global_code[i].arg2.args_type<<")\t(" << global_code[i].result.var << "," << global_code[i].result.temp << "," << global_code[i].result.int_val << "," << global_code[i].result.float_val << "," << global_code[i].result.args_type<< ")\n";

								}	
								printf("===============CODE GENERATION END====================\n");
							#endif 
	                       struct symbol_table *temp = current_symbol_table;
                       		int flag = 1;
                        	while(flag) {
                                        if( temp->table.find(string( $1->var_name[0])) != temp->table.end()){
                                                $$->my_type = temp->table[string($1->var_name[0])].my_type;
                                                flag = 0;
						$$->dimension[0] = temp->table[string($1->var_name[0])].dimension - $1->dimension[0];

                                	}
                                	if(temp->parent==NULL && flag==1) {
                                        	yyerror("error: variable not declared\n");
                                        	flag = 0;
                                	}
                                	temp = temp->parent;
                        	}
				enum type_enum t = $$->my_type;
				enum type_enum tt = $3->my_type; 
				if (t == Int && tt== Long_long)
					yyerror("Warning: assigning long long to an integer\n",KYEL);
				else if (t==Int && tt == Float)
					yyerror("Warning: assigning float to an int\n",KYEL);
				else if (t==Int && tt == Double)
					yyerror("Warning: assigning int to double\n",KYEL);
				else if (t==Float && tt == Double)
					yyerror("Warning: assigning float to a double\n",KYEL);
				else if (t==Long_long && tt == Float)
					yyerror("Warning: assigning long long to a float\n",KYEL);
				else if (t==Long_long && tt == Double)
					yyerror("Warning: assigning long long to a double\n",KYEL);
				else if (t != tt || $$->dimension != $3->dimension )
					yyerror("Warning: Type mismatch\n",KYEL);

				free($1);
				free($3);

				}/*Assignment statement.*/
	;
number : T_DEC_INT	{
						#ifdef debug 
							printf("number-> T_DEC_INT\n");
						#endif
						$$ = new attr();
						$$->place.int_val = $1;
						$$->place.args_type = 3;
						$$->my_type =Int;
					}
	| T_DEC_FLOAT {
						$$ = new attr();
						$$->place.float_val = $1;
						$$->place.args_type = 4;
						$$->my_type = Int;
					}
	;

identifier  : ID	{  	
						$$ = new attr();
						$$->place.var = $1;
						$$->place.args_type = 1;
						strcpy($$->var_name[0],$1);
							$$->dimension[0] = 0;
					 }/*Array can have infinite dimensions. Must do something about it in future.*/ 
		| ID array {
							$$ = (attr*)malloc(sizeof(attr));
							strcpy($$->var_name[0],$1);
							$$->dimension[0] = $2->dimension[0];
							free($2);
		}
	;
array  : '[' ID ']' array  {$$ = (attr*)malloc(sizeof(attr)); $$->dimension[0] = $4->dimension[0] +1; printf("%s",$2); free($4);}
	| '[' ID ']' {$$ = (attr*)malloc(sizeof(attr)); $$->dimension[0] = 1;}
	| '[' T_DEC_INT ']' {$$ = (attr*)malloc(sizeof(attr));  $$->dimension[0] = 1;}
	| '[' T_DEC_INT ']' array {$$ = (attr*)malloc(sizeof(attr)); $$->dimension[0] = $4->dimension[0] + 1; free($4);}
	;
%%


int main()
{
		no_line = 1;
		maindef = 0;
		current_symbol_table = new symbol_table;
		current_symbol_table->parent = NULL;
        yyparse();
        if (!maindef) yyerror("main function not defined");
		return 0;
}
